[
  {
    "id": "1733971462275",
    "content": "/**\n * @format\n */\n\nconst checkUserName = (username) => {\n\treturn username.length >= 8;\n};\n\nconst checkPassWord = (password) => {\n\treturn password.length >= 6;\n};\n\n// 导出 (基于 CommonJS 标准语法)\nmodule.exports = {\n\tcheckUser: checkUserName,\n\tcheckPwd: checkPassWord,\n};",
    "timestamp": "2024-12-12T02:44:22.275Z"
  },
  {
    "id": "1733971407257",
    "content": "/** @format */\n\n// 导入 (基于 CommonJS 标准语法)\nconst obj1 = require('./lib/arr.js');\nconst obj2 = require('./lib/str.js');\n// console.log(obj1.getArraySum([1, 2, 3]));\n// console.log(obj2.checkUser('1111'));\n// console.log(obj2.checkPwd('12345678'));\n\n// 导出 (基于 CommonJS 标准语法)\nmodule.exports = {\n\t...obj1,\n\t...obj2,\n};\n",
    "timestamp": "2024-12-12T02:43:27.257Z"
  },
  {
    "id": "1733971386837",
    "content": "/** @format */\n\n// 导入 (基于 CommonJS 标准语法)\nconst objServer = require('./utils/index.js');\nconsole.log(objServer);\n// console.log(objServer.obj1);\n// console.log(objServer.obj2);\n// console.log(objServer.obj1.getArraySum([1, 2, 3]));\n// console.log(objServer.obj2.checkUser('1111'));\n// console.log(objServer.obj2.checkPwd('12345678'));\n",
    "timestamp": "2024-12-12T02:43:06.837Z"
  },
  {
    "id": "1733914878940",
    "content": "瑞安·达尔Ryan Dahl 的 个人网站： https://tinyclouds.org/\nTwitter： https://x.com/rough__sea\nGitHub：  https://github.com/ry",
    "timestamp": "2024-12-11T11:01:18.940Z"
  },
  {
    "id": "1733914851975",
    "content": "```js\nconsole.log(data.toString());\n\nconsole.log(JSON.parse(data.toString()));\nconsole.log(JSON.parse(data));\n```",
    "timestamp": "2024-12-11T11:00:51.975Z"
  },
  {
    "id": "1732757149008",
    "content": "### Promise 的核心作用\n\n##### 1. **处理异步操作的结果**\n   - 将异步操作封装成 Promise 对象\n   - 使用 `.then()` 和 `.catch()` 处理异步结果\n   - 避免 **回调地狱(callback hell)** 问题\n\n- 不仅仅是传递变量，更重要的是处理异步操作的结果\n- 异步操作可能成功，也可能失败\n\n看一个简单的例子：\n```javascript\n// 没有 Promise 的情况\nfunction getData(callback) {\n  setTimeout(() => {\n    const data = { name: '张三' };\n    callback(data);  // 通过回调函数获取数据\n  }, 1000);\n}\n\ngetData((result) => {\n  console.log(result);\n});\n\n// 使用 Promise 的情况\nfunction getData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const data = { name: '张三' };\n      resolve(data);  // 通过 resolve 传递结果\n    }, 1000);\n  });\n}\n\ngetData()\n  .then(result => {\n    console.log(result);\n  });\n```\n\n\n### 为什么要用 Promise？\n##### 1. **避免回调地狱**\n**回调地狱（Callback Hell）** 就是 **回调函数的层层嵌套** 。\n```javascript\n// 回调地狱\ngetData(function(result1) {\n  getMoreData(result1, function(result2) {\n    getMoreData2(result2, function(result3) {\n      console.log(result3);\n    });\n  });\n});\n\n// 使用 Promise\ngetData()\n  .then(result1 => getMoreData(result1))\n  .then(result2 => getMoreData2(result2))\n  .then(result3 => {\n    console.log(result3);\n  });\n```\n\n回调地狱的问题\n1. **代码可读性差**\n   - 代码向右偏移，形成\"金字塔\"形状\n   - 逻辑顺序难以理解\n2. **错误处理复杂**\n   - 每层都需要单独的错误处理\n   - 容易遗漏错误处理\n3. **代码维护困难**\n   - 难以修改或重构\n   - 难以进行单元测试\n\nPromise 的优势\n1. **链式调用**\n   - 扁平的代码结构\n   - 清晰的执行顺序\n2. **统一的错误处理**\n   - 使用单个 `.catch()` 处理错误\n   - 更容易处理异常情况\n3. **更好的代码组织**\n   - 便于维护和重构\n   - 支持更多的异步操作模式（如 `Promise.all()`）\n\nasync/await 的进一步优势\n1. **同步代码的写法**\n   - 更直观\n   - 更容易理解\n2. **更好的错误处理**\n   - 使用传统的 try/catch\n   - 更符合直觉\n\n所以，回调地狱不仅影响代码的可读性，还会带来维护和错误处理的困难。这也是为什么现代 JavaScript 推荐使用 Promise 和 async/await 的原因。\n##### 2. **更好的错误处理**\n```javascript\naxios({\n  url: 'https://api.example.com/data'\n})\n.then(res => {\n  // 处理成功的情况\n  console.log(res.data);\n})\n.catch(err => {\n  // 统一处理错误\n  console.log('发生错误：', err);\n});\n```\n\n##### 3. **状态管理**\n   - pending(进行中)\n   - fulfilled(已成功)\n   - rejected(已失败)\n   \n所以，Promise 不仅仅是为了传递变量，而是：\n1. 更优雅地处理异步操作\n2. 更清晰的代码结构\n3. 更统一的错误处理\n4. 支持链式调用\n5. 避免回调函数层层嵌套\n\n这就是为什么在现代 JavaScript 中，Promise 成为处理异步操作的标准方式。",
    "timestamp": "2024-11-28T01:25:49.008Z"
  },
  {
    "id": "1732757129055",
    "content": "这个内部机制：\n\n1. **Promise 的内部实现**：\n```javascript\n// 这是简化版的 Promise 内部实现原理\nclass MyPromise {\n    constructor(executor) {\n        this.status = 'pending';  // Promise 状态\n        this.value = undefined;   // 成功的值\n        this.error = undefined;   // 失败的原因\n        this.onFulfilledCallbacks = [];  // 存储 then 的回调函数\n        \n        // 定义 resolve 函数\n        const resolve = (value) => {\n            if (this.status === 'pending') {\n                this.status = 'fulfilled';\n                this.value = value;\n                // 执行所有 then 的回调\n                this.onFulfilledCallbacks.forEach(fn => fn(value));\n            }\n        };\n        \n        // 执行器函数立即执行\n        executor(resolve, reject);\n    }\n    \n    then(onFulfilled) {\n        if (this.status === 'pending') {\n            // 把 then 的回调存起来\n            this.onFulfilledCallbacks.push(onFulfilled);\n        }\n        // ...其他状态处理\n    }\n}\n```\n\n2. **执行过程**：\n```javascript\n// 当我们写这样的代码时\nconst p = new Promise(function(fn2, fn3) {\n    // 当调用 fn2(resObj) 时\n    xhr.addEventListener('loadend', () => {\n        const resObj = JSON.parse(xhr.response);\n        fn2(resObj);  // 这里实际上调用了 resolve(resObj)\n    });\n});\n\n// then 的回调会被存储起来\np.then(function fn22(res) {  // fn22 被存储在 Promise 内部\n    console.log(res);\n});\n```\n\n3. **触发过程**：\n- 当 `fn2(resObj)` 被调用时，实际上调用了 Promise 内部的 `resolve` 函数\n- `resolve` 函数会：\n  1. 改变 Promise 的状态为 `fulfilled`\n  2. 保存成功的值 `resObj`\n  3. 执行之前通过 `then` 存储的回调函数（即 `fn22`）\n\n所以整个流程是：\n```\nfn2(resObj) 调用 \n→ 触发内部 resolve 函数 \n→ 改变状态和保存值 \n→ 执行存储的 then 回调(fn22)\n```\n\n这就是为什么调用 `fn2(resObj)` 会触发 `fn22` 的执行。这个机制是 Promise 内部实现的，目的是为了管理异步操作的状态和回调。\n\n这也解释了为什么我们说 Promise 是一个异步编程的解决方案，它通过这种巧妙的设计，把异步操作的结果和后续处理通过 `then` 链接起来。",
    "timestamp": "2024-11-28T01:25:29.055Z"
  },
  {
    "id": "1732757106233",
    "content": "promise 对象的调用关系：\n\n\n1. **关于 fn1**：\n```javascript:1.html\nconst p = new Promise(function fn1(fn2, fn3) {\n```\n- `fn1` 是 Promise 构造函数的参数，是一个执行器函数(executor)\n- `fn2` 和 `fn3` 是 `fn1` 的形参，它们实际上就是 Promise 内部提供的 `resolve` 和 `reject` 函数\n\n2. **关于 fn2/fn3 的调用**：\n```javascript:1.html\nfn2(resObj);    // 这里调用的是 resolve\nfn3('失败');     // 这里调用的是 reject\n```\n- `fn2()` 和 `fn3()` 是函数调用\n- 这里是在执行器函数内部调用了这两个函数\n- Promise 内部机制决定了只有第一次调用 `resolve` 或 `reject` 才会生效\n\n3. **关于 fn22 和 fn33**：\n```javascript:1.html\np.then(function fn22(res) {\n    // ...\n})\n.catch(function fn33(err) {\n    // ...\n});\n```\n- `fn22` 是 `.then()` 的回调函数，是实参\n- `fn33` 是 `.catch()` 的回调函数，是实参\n- 当 `fn2(resObj)` (resolve) 被调用时，会触发 `fn22` 的执行\n- 当 `fn3('失败')` (reject) 被调用时，会触发 `fn33` 的执行\n\n调用关系总结：\n1. Promise 构造函数调用了 `fn1`\n2. `fn1` 内部调用了 `fn2` (resolve) 或 `fn3` (reject)\n3. Promise 内部机制根据 `fn2`/`fn3` 的调用来决定执行 `fn22` 还是 `fn33`\n\n所以整个流程是：\n```\nPromise构造函数 -> fn1 -> fn2/fn3 -> fn22/fn33\n```\n\n这就是为什么我们说 Promise 能够管理异步操作，\n它通过这种 **函数调用链** 来确保异步操作的结果能够被正确地处理。",
    "timestamp": "2024-11-28T01:25:06.233Z"
  },
  {
    "id": "1732757023525",
    "content": "事件循环：\n- 调用栈（js 的同步代码）\n- 宿主环境（浏览器）（等待时间的异步任务）\n- 任务队列（到时间的异步任务）",
    "timestamp": "2024-11-28T01:23:43.525Z"
  },
  {
    "id": "1732583239296",
    "content": "使用 FormData，获取图片，并提交到服务器：\n目标：图片上传，显示到网页上\n1. 获取图片文件\n2. 使用 FormData 携带图片文件\n3. 提交到服务器，获取图片url网址使用",
    "timestamp": "2024-11-26T01:07:19.296Z"
  },
  {
    "id": "1732493755622",
    "content": "Prettier 的设置可以通过多种方式进行配置，主要包括用户设置、工作区设置和项目特定的配置文件（如 .prettierrc.js）。每种设置方式都有其适用的场景和优先级。下面详细介绍这三者的区别、设置方法以及优先级。",
    "timestamp": "2024-11-25T00:15:55.622Z"
  },
  {
    "id": "1732493742272",
    "content": "vscode 配置 ruler\nvscode中竖线怎么设置\nVScode的垂直竖线设置（ruler设置）\nvscode显示120字符提示线或者显示垂直标尺\nvscode 设置80标尺线",
    "timestamp": "2024-11-25T00:15:42.272Z"
  },
  {
    "id": "1732064591761",
    "content": "js 中点语法和中括号语法：\n\n笔记中位置：\n225 号: P54/55/56/57\n- `.` 点语法\n- `[]` 中括号语法",
    "timestamp": "2024-11-20T01:03:11.761Z"
  },
  {
    "id": "1732064574373",
    "content": "js 中，函数分为哪几种？\n\n1. 按照定义方式分类\n1.1. 函数声明\n1.2. 函数表达式\n1.3. 箭头函数\n2. 按照参数数量分类\n2.1. 可变参数函数\n2.2. 固定参数函数\n3. 按照返回值分类\n3.1. 返回值函数\n3.2. 没有返回值的函数（即返回 undefined）\n4. 按照作用域和上下文分类\n4.1. 普通函数（全局函数）\n4.2. 方法\n5. 按照使用场景分类\n5.1. 普通函数\n5.2. 回调函数\n5.3. 立即调用的函数表达式 (IIFE)\n6. 按照对象区分\n6.1. 普通函数\n6.2. 构造函数\n6.3. 类方法（ES6 引入）\n总结",
    "timestamp": "2024-11-20T01:02:54.373Z"
  },
  {
    "id": "1731977424097",
    "content": "道： 大象无形\n释： 凡所有象， 皆为虚妄\n儒： 君子不器",
    "timestamp": "2024-11-19T00:50:24.097Z"
  },
  {
    "id": "1731977279669",
    "content": "关于睡眠的3-2-1法则:\n- 睡前3小时停止进食\n- 睡前2小时停止饮水\n- 睡前1小时停止使用电子屏幕",
    "timestamp": "2024-11-19T00:47:59.669Z"
  },
  {
    "id": "1731977271173",
    "content": "脑海中有个概念：信息审美。",
    "timestamp": "2024-11-19T00:47:51.173Z"
  },
  {
    "id": "1731977262190",
    "content": "少则得，多则惑。\n\n大家都听了很多「做减法」，「要克制」，但轮到自己动手时，总是忍不住：这个功能太帅了，那个功能所有竞品都有，新设计的交互太 𝓒𝓸𝓸𝓵 了...加着加着, 产品就变成了--一款普通产品。",
    "timestamp": "2024-11-19T00:47:42.190Z"
  },
  {
    "id": "1731977248058",
    "content": "它是工具，你一定要比工具凶！\n你要握剑，别被剑给控制了。",
    "timestamp": "2024-11-19T00:47:28.058Z"
  },
  {
    "id": "1731977235704",
    "content": "新华字典就是答案之书。\n随手翻到一页，视线聚焦的那个字，就是你想要的答案。",
    "timestamp": "2024-11-19T00:47:15.704Z"
  },
  {
    "id": "1731889722296",
    "content": "构造函数（Constructor）：是一个用于创建对象的传统 JavaScript 函数，通常以大写字母开头。\n\nfunction MyConstructor() {}\nconst myInstance = new MyConstructor();\n实例对象（Instance/Object Instance）：是使用构造函数创建的特定对象。每个实例都有其自己的属性和方法，可以独立于其他实例存在。",
    "timestamp": "2024-11-18T00:28:42.296Z"
  },
  {
    "id": "1731889713632",
    "content": "构造函数：Array 是 JavaScript 内置的构造函数之一，用于创建数组对象。构造函数可以用于生成单个特定的对象实例，在这种情况下，它生成了一个新的数组实例。\n\n实例对象：arr 是使用 new Array(...) 语法创建的对象实例。在这个例子中，arr 是一个数组实例，它的内容是 [2, 3]。",
    "timestamp": "2024-11-18T00:28:33.632Z"
  },
  {
    "id": "1731889704577",
    "content": "在 JavaScript 中，当你使用 const arr = new Array(2, 3); 时，arr 被称为“实例对象”或“实例”，而 Array 是一个“构造函数”。",
    "timestamp": "2024-11-18T00:28:24.577Z"
  },
  {
    "id": "1731889688078",
    "content": "new Object()构造函数只接受一个参数，而不是多个参数",
    "timestamp": "2024-11-18T00:28:08.078Z"
  },
  {
    "id": "1731837671522",
    "content": "查询相机快门次数",
    "timestamp": "2024-11-17T10:01:11.522Z"
  },
  {
    "id": "1731837660598",
    "content": "类似 memos 的闪念笔记blinko",
    "timestamp": "2024-11-17T10:01:00.598Z"
  },
  {
    "id": "1731837650901",
    "content": "鞋子时间长不穿，就发霉了",
    "timestamp": "2024-11-17T10:00:50.901Z"
  },
  {
    "id": "1731547049536",
    "content": "世界上最大的监狱就是你的大脑",
    "timestamp": "2024-11-14T01:17:29.536Z"
  },
  {
    "id": "1731483676968",
    "content": "我最喜欢的画图工具是 Excalidraw ，手绘风格，简单漂亮，但是它的在线版本不支持中文手写体，并且画好的结果经常就丢了，不方便在本地备份，所以我一般是用 Obsidian ，一款本地笔记软件，再安装 Obsidian-Excalidraw 插件",
    "timestamp": "2024-11-13T07:41:16.968Z"
  },
  {
    "id": "1731403953308",
    "content": "以无厚入有间",
    "timestamp": "2024-11-12T09:32:33.308Z"
  },
  {
    "id": "1731289372647",
    "content": "在 JavaScript 中，`ele` 和 `item` 只是变量名的选择，实际上并没有特定的含义或功能区别。\n它们通常用作变量名以表示不同的对象或元素，具体取决于开发者的命名习惯。\n\n- `ele` 通常是 \"element\" 的缩写，常用于表示 DOM 元素或者某种结构化元素。\n- `item` 通常用于表示某个集合中的单个项目，比如数组或列表中的一个元素。",
    "timestamp": "2024-11-11T01:42:52.647Z"
  },
  {
    "id": "1731027170638",
    "content": "在 js 中,查找一个节点,可以使用document.querySelector(''),也可以使用parentNode,children,previousElementSibling,这两种方法有什么区别?为什么需要存在这两种?document.querySelector('') 已经满足使用了啊\n\n总结：\n类似于「**绝对路径**」和「**相对路径**」，都非常有必要存在。\n使用在不同的场景中。",
    "timestamp": "2024-11-08T00:52:50.638Z"
  },
  {
    "id": "1731027159909",
    "content": "\n`swipe: function() {代码}` 这种写法是 JavaScript 中的对象字面量（object literal）语法。在这里，`swipe` 是对象的一个属性名，属性值是一个函数（anonymous function，即没有名称的函数）。\n",
    "timestamp": "2024-11-08T00:52:39.909Z"
  },
  {
    "id": "1731027102720",
    "content": "- **遍历数组**：更强调**查询获取**\n- **迭代数组**：更强调**修改**",
    "timestamp": "2024-11-08T00:51:42.720Z"
  },
  {
    "id": "1731027078311",
    "content": "draw.io: 当公司付钱给我们时，应该是因为我们增加了价值，而不是因为他们被锁定了。\n\nhttps://www.drawio.com/about\n\nWe promise you we won’t hide your data from you and will always give you some way to open and edit that data, at no cost. When companies pay us money it should be because we add value, not because they are locked in.\n我们向您保证，我们不会向您隐藏您的数据，并且始终为您提供一些免费打开和编辑该数据的方法。当公司付钱给我们时，应该是因为我们增加了价值，而不是因为他们被锁定了。",
    "timestamp": "2024-11-08T00:51:18.311Z"
  },
  {
    "id": "1731027043588",
    "content": "form 表单：重置表单的两种方式\n\n添加 `form.reset()` 来清空表单\n`reset()` 是表单对象的内置方法，可以将表单所有输入框重置为初始状态\n这样用户添加完数据后就不需要手动清空输入框了，提高了使用体验\n",
    "timestamp": "2024-11-08T00:50:43.588Z"
  },
  {
    "id": "1731027034943",
    "content": "为什么需要打开 e.preventDefault()：\n- 在表单(form)提交时，浏览器默认行为是刷新页面或跳转。这意味着：\n- 如果不阻止默认行为，页面会立即刷新\n- 刷新后，console.log(obj) 的内容会立即消失，来不及看到打印结果",
    "timestamp": "2024-11-08T00:50:34.943Z"
  },
  {
    "id": "1731027022457",
    "content": "`confirm()` 是 JavaScript 的一个内置函数，它会显示一个带有指定消息和\"确定\"、\"取消\"按钮的对话框。\n\n它的主要特点是：\n\n1. 语法：`window.confirm(message)` 或简写为 `confirm(message)`\n2. 返回值：\n   - 如果用户点击\"确定\"，返回 `true`\n   - 如果用户点击\"取消\"，返回 `false`",
    "timestamp": "2024-11-08T00:50:22.457Z"
  },
  {
    "id": "1731026937044",
    "content": "闭包的概念出现于60年代，最早实现闭包的进程语言是[Scheme](https://www.frdic.com/dicts/wiki/Scheme.html \"Scheme\")。之后，闭包被广泛使用于函数式编程语言如[ML语言](https://www.frdic.com/dicts/wiki/ML%E8%AF%AD%E8%A8%80.html \"ML语言\")和[LISP](https://www.frdic.com/dicts/wiki/LISP.html \"LISP\")。很多命令式进程语言也开始支持闭包。",
    "timestamp": "2024-11-08T00:48:57.044Z"
  },
  {
    "id": "1730936092023",
    "content": "9小时前 — 美国前总统唐纳德·特朗普（Donald Trump）击败现任副总统卡玛拉·哈里斯（Kamala Harris），赢得了一个新的为期四年的总统任期。",
    "timestamp": "2024-11-06T23:34:52.023Z"
  },
  {
    "id": "1730852567638",
    "content": "AlloyFinger 非常轻量的开源手势库\nAlloyFinger 是由腾讯前端团队 AlloyTeam 出品的一个小巧轻量级的移动端手势库，整个手势库的代码不超过400行，却支持绝大多数的手势操作，能够满足日常的开发需求。\n\nAlloyFinger传送门（github）： AlloyFinger https://github.com/AlloyTeam/AlloyFinger 。\n\n网站地址:http://alloyteam.github.io/AlloyFinger/\nGitHub:https://github.com/AlloyTeam/AlloyFinger\n网站描述:一款非常轻量的开源手势库\n\n## 引入在线 js 地址：\n```js\n<script src=\"https://unpkg.com/alloyfinger@0.1.16/alloy_finger.js\"></script>\n```\n\n## js 文件下载地址：\nhttp://alloyteam.github.io/AlloyFinger/alloy_finger.js",
    "timestamp": "2024-11-06T00:22:47.638Z"
  },
  {
    "id": "1730766748532",
    "content": "- `parseInt()` 可以接受第二个参数指定进制，更适合用于字符串解析场景\n- `Math.floor()` 专注于数字运算，更适合纯数学计算场景",
    "timestamp": "2024-11-05T00:32:28.532Z"
  },
  {
    "id": "1730766714013",
    "content": "// parseInt 示例\nparseInt(3.9)    // 返回 3\nparseInt(-3.9)   // 返回 -3\nparseInt(\"3.9\")  // 返回 3\n\n// Math.floor 示例\nMath.floor(3.9)  // 返回 3\nMath.floor(-3.9) // 返回 -4\nMath.floor(\"3.9\") // 返回 3",
    "timestamp": "2024-11-05T00:31:54.013Z"
  },
  {
    "id": "1730677403438",
    "content": "图片像素：\n- 是图片文件的固有属性\n- 纯数据概念，与显示无关\n- 单纯表示颜色信息点的数量\n\nCSS像素（逻辑像素）：\n- 是Web布局的单位\n- 与显示设备相关\n- 会根据设备像素比(DPR)自动缩放\n\n物理像素：\n- 是显示设备的发光点\n- 硬件概念\n- 实际显示单元",
    "timestamp": "2024-11-03T23:43:23.438Z"
  },
  {
    "id": "1730677390528",
    "content": "现代移动设备都采用这种双层分辨率（逻辑和物理）的设计",
    "timestamp": "2024-11-03T23:43:10.528Z"
  },
  {
    "id": "1730600021034",
    "content": "js 中函数的创建方式（构造函数）的方式\n\n在 JavaScript 中，创建函数的方法有几种，主要包括以下几种：\n\n1. **函数声明（Function Declaration）**：\n   这是最常见的定义函数的方法，使用 `function` 关键字。\n\n   ```javascript\n   function add(a, b) {\n       return a + b;\n   }\n   ```\n\n2. **函数表达式（Function Expression）**：\n   通过将 `function` 关键字与可选的函数名结合，用于创建一个匿名函数或具名函数，并将其赋值给变量。\n\n   - 匿名函数表达式：\n\n   ```javascript\n   const add = function(a, b) {\n       return a + b;\n   };\n   ```\n\n   - 具名函数表达式：\n\n   ```javascript\n   const add = function addFunc(a, b) {\n       return a + b;\n   };\n   ```\n\n3. **箭头函数（Arrow Function）**：\n   ES6 引入的简洁的函数定义语法。箭头函数不绑定自身的 `this`，使它在某些场合下非常有用。\n\n   ```javascript\n   const add = (a, b) => {\n       return a + b;\n   };\n\n   // 若只有一个表达式，可以省略大括号和 return\n   const add = (a, b) => a + b;\n   ```\n\n4. **立即调用的函数表达式（IIFE, Immediately Invoked Function Expression）**：\n   这种函数在定义后立即执行。\n\n   ```javascript\n   (function() {\n       console.log(\"This function runs immediately.\");\n   })();\n   ```\n\n5. **构造函数（Constructor Function）**：\n   使用 `new` 关键字创建对象的函数。\n\n   ```javascript\n   function Person(name) {\n       this.name = name;\n   }\n\n   const john = new Person('John');\n   ```\n\n6. **类方法（Method）**：\n   在 ES6 中，可以使用类定义方法。\n\n   ```javascript\n   class Person {\n       constructor(name) {\n           this.name = name;\n       }\n\n       greet() {\n           console.log(`Hello, my name is ${this.name}`);\n       }\n   }\n\n   const john = new Person('John');\n   john.greet();\n   ```\n\n这些是 JavaScript 中创建函数的主要方式。你可以根据需要选择适合的方式来定义函数。",
    "timestamp": "2024-11-03T02:13:41.034Z"
  },
  {
    "id": "1730599994527",
    "content": "px？dp？pt？界面设计尺寸\nhttps://www.bilibili.com/video/BV1PY4y1K7GK/\n\nhttps://www.bilibili.com/video/BV11v411M7vB/",
    "timestamp": "2024-11-03T02:13:14.527Z"
  },
  {
    "id": "1730599982591",
    "content": "Windows 一键预览软件 seer 和 quicklook\nhttps://sspai.com/post/43664\n\nhttps://sspai.com/post/31712\nhttp://1218.io/",
    "timestamp": "2024-11-03T02:13:02.591Z"
  },
  {
    "id": "1730599905165",
    "content": "重新认识Pixel、DPI PPI 以及像素密度\nhttps://editor.leonh.space/2021/rediscover-pixel-dpi-ppi-and-pixel-density/",
    "timestamp": "2024-11-03T02:11:45.165Z"
  },
  {
    "id": "1730599889176",
    "content": "Device Pixel Ratio 设备像素比\nhttps://www.oxyplug.com/optimization/device-pixel-ratio/\n",
    "timestamp": "2024-11-03T02:11:29.176Z"
  },
  {
    "id": "1730530461559",
    "content": "```html\n<script>\n\t// 添加边界检查:数组的正常范围是[0,arrDate.length-1],如果比最小值 0 还小，\n\t// 则：循环到最后一张\n\tif (num < 0) {\n\t\tnum = arrDate.length - 1;\n\t}\n\t// 添加边界检查:数组的正常范围是[0,arrDate.length-1],如果比最大值arrDate.length-1还大，\n\t// 则：循环到第一张\n\tif (num > arrDate.length - 1) {\n\t\tnum = 0;\n\t}\n</script>\n```",
    "timestamp": "2024-11-02T06:54:21.559Z"
  },
  {
    "id": "1730530360979",
    "content": "js 中回调函数「函数的引用」和「函数的调用」",
    "timestamp": "2024-11-02T06:52:40.979Z"
  },
  {
    "id": "1730427156189",
    "content": "cursor 这样的小提示真的太好了，不用一个一个去调试。\n一句话，几秒钟就搞定了。",
    "timestamp": "2024-11-01T02:12:36.189Z"
  },
  {
    "id": "1730333677215",
    "content": "js 中获取整个 body 的标签：document.body",
    "timestamp": "2024-10-31T00:14:37.215Z"
  },
  {
    "id": "1730333667524",
    "content": "prototype \nNAmE /ˈproʊtətaɪp/\nBrE /ˈprəʊtətaɪp/ \n\nprototype：NodeList\nprototype：Array",
    "timestamp": "2024-10-31T00:14:27.524Z"
  },
  {
    "id": "1730248498517",
    "content": "VSCode神技-让双手不离键盘\nhttps://juejin.cn/post/6844904119224926216",
    "timestamp": "2024-10-30T00:34:58.517Z"
  },
  {
    "id": "1730210055107",
    "content": "Cursor一键导入vscode插件以及设置\n\n从 VS Code 迁移\n导入扩展、主题、设置和快捷键绑定 \n您可以一键将您的 VS Code 配置导入到 Cursor。\n\n在cursor中找到 setting-- general -- vscode import 导入配置，一键导入即可。",
    "timestamp": "2024-10-29T13:54:15.107Z"
  },
  {
    "id": "1730210042583",
    "content": "### `console.log()`\n- 用来输出一般信息，例如字符串、数字、对象、数组等。\n- 输出的格式会自动格式化，适合简单的调试。\n- 对于对象，如果对象比较复杂，它会以字符串形式打印出来，并在控制台中默认展开以查看其属性和方法。\n\n### `console.dir()`\n- 用于输出一个对象的可枚举属性，提供更为详细和结构化的信息。\n- 默认情况下，`console.dir()`会以树形结构展示对象，可以展开和折叠，以查看更多的属性。\n- 更适合用于查看对象的属性和结构，特别是在想要查看 DOM 元素时。",
    "timestamp": "2024-10-29T13:54:02.583Z"
  },
  {
    "id": "1730210022465",
    "content": "完整的JavaScript包括以下几个部分：\n- **ECMAScript**，描述了该语言的语法和基本对象；\n- **文档对象模型（[DOM](https://zh.wikipedia.org/wiki/DOM \"DOM\")）** ，描述处理**网页内容**的方法和接口；\n- **浏览器对象模型（[BOM](https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B \"浏览器对象模型\")）** ，描述与**浏览器**进行交互的方法和接口。\n\n其中，DOM 和 BOM，一起叫做 **webAPI** 。",
    "timestamp": "2024-10-29T13:53:42.465Z"
  },
  {
    "id": "1730210009491",
    "content": "维基：ECMAScript\nhttps://zh.wikipedia.org/wiki/ECMAScript#cite_note-1\n\n维基：JavaScript\nhttps://zh.wikipedia.org/wiki/JavaScript",
    "timestamp": "2024-10-29T13:53:29.491Z"
  },
  {
    "id": "1730209992537",
    "content": "vscode 删除当前行快捷键：⌘+delete 键和⌘+shift+K",
    "timestamp": "2024-10-29T13:53:12.537Z"
  },
  {
    "id": "1729818374767",
    "content": "这些年苹果相当于把卖手机卖电脑的钱，都砸进去做芯片了。苹果的芯片，一代比一代强。",
    "timestamp": "2024-10-25T01:06:14.767Z"
  },
  {
    "id": "1729818347966",
    "content": "David Adjaye 从尤鲁巴雕塑中汲取灵感，Steve Jobs 则从禅宗佛教和书法中得到启发。\n\n\n这样的例子数不胜数，但这并不是重点。重点是跳出行业的束缚，去寻找那些让我们感动的事物，并问自己为什么会感动。借鉴它们，融合它们，让它们塑造你的作品！",
    "timestamp": "2024-10-25T01:05:47.966Z"
  },
  {
    "id": "1729818339791",
    "content": "扮演 KOL，而不是企业。\n\n\n社交媒体一再证明，人们更关心的是人，而不是品牌。这也是网红营销受欢迎的原因。\n\n\n如果你想和受众建立紧密联系，就需要展示自己，展现个性，避免使用那种官方的企业语言。\n\n\n这就是为什么 Arc 的视频通常是 vlog 风格的，像典型的 YouTube 创作者一样。他们展示董事会会议、团队建设活动，还有初创公司日常生活的幕后花絮。这类内容让人们感觉自己参与了整个旅程。",
    "timestamp": "2024-10-25T01:05:39.791Z"
  },
  {
    "id": "1729818330083",
    "content": "Keep calm and carry on.心中有光，坚定前行。",
    "timestamp": "2024-10-25T01:05:30.083Z"
  },
  {
    "id": "1729818316830",
    "content": "如果所有人都会编程，那么这个国度一定会变得更好。因为，更多人学会了逻辑，会用理性抵御操纵，不至于被权势者愚弄。",
    "timestamp": "2024-10-25T01:05:16.830Z"
  },
  {
    "id": "1729638449377",
    "content": "css小技巧css-tricks.com\n\nhttps://css-tricks.com/snippets/css/a-guide-to-flexbox/#flexbox-background",
    "timestamp": "2024-10-22T23:07:29.377Z"
  },
  {
    "id": "1729556818980",
    "content": "\"out\": \"../css/\"",
    "timestamp": "2024-10-22T00:26:58.980Z"
  },
  {
    "id": "1729556796718",
    "content": "Heron Handoff for Figma :一键导出设计标注和切图资源",
    "timestamp": "2024-10-22T00:26:36.718Z"
  },
  {
    "id": "1729471337473",
    "content": "4K 显示器，现在显示器相比几年前真的白菜价。",
    "timestamp": "2024-10-21T00:42:17.473Z"
  },
  {
    "id": "1729471327841",
    "content": "我想我得适应未来的生活，未来大多数人都付不起保姆和家政的人工费，届时生活中大部分日常工作都得靠机器人。",
    "timestamp": "2024-10-21T00:42:07.841Z"
  },
  {
    "id": "1729471311332",
    "content": "块引用的存在是为了在 daily notes 中实现卡片关联和引用，可以随便写一些什么东西，同时在后期也可以拖动和整理。\n\n如哈桑所言，降低了写入的心智负担，不再需要考虑写在哪里，归属在哪里的问题。",
    "timestamp": "2024-10-21T00:41:51.332Z"
  },
  {
    "id": "1729471289035",
    "content": "**科举取士以牢笼志士：**\n“科举取士以牢笼志士”这句话的意思是通过科举考试来选拔人才，但这种方式实际上限制了有志之士的发展和追求。\n这句话反映了一种对科举制度的批评，认为科举考试的形式化和功利化可能会束缚真正有志向和理想的人，使他们只成为科举制度的工具，而无法实现更高的理想。\n这种观点常常出现在对历史上科举制度的讨论中，尤其是在强调人才应有更广阔的发展空间，以及强调个人理想和价值的背景下。",
    "timestamp": "2024-10-21T00:41:29.035Z"
  },
  {
    "id": "1729471269996",
    "content": "先意识到互联网在对每一个人进行一场精神世界的狙击，精准打击每一个人的多巴胺偏好。\n\n然后再去寻找专业领域的知识，专业领域的课本和内容，时刻记住自己的目标是什么。",
    "timestamp": "2024-10-21T00:41:09.996Z"
  },
  {
    "id": "1729471222857",
    "content": "写一篇博客，就是跟未来的自己约会。",
    "timestamp": "2024-10-21T00:40:22.857Z"
  },
  {
    "id": "1729471198379",
    "content": "在HTML中，**不允许嵌套`<a>`标签**。根据HTML标准，链接（`<a>`元素）不能包含其他链接。这种做法被认为是不合规的，可能导致浏览器在渲染时出现意外行为或错误。",
    "timestamp": "2024-10-21T00:39:58.379Z"
  },
  {
    "id": "1729471187260",
    "content": "这样的代码注释和折叠，才是干净清爽的。",
    "timestamp": "2024-10-21T00:39:47.260Z"
  },
  {
    "id": "1729392040966",
    "content": "今天把床🛏搬进了我的书房，只拿了床垫，看着真是舒服啊。特别是风一吹，窗帘随风飘动，太有感觉。而且今天不知道怎么了，一直睡不醒。结果就是，国庆节第一天，本来8点醒了，吃完早饭忙完，又睡到12点。",
    "timestamp": "2024-10-20T02:40:40.966Z"
  },
  {
    "id": "1729392033066",
    "content": "自 macOS Sequoia（15.0） 起，Apple 加强了对屏幕录制权限的隐私控制。在正式版中，每隔一个月，系统就会通过弹窗设置要求用户对应用授予屏幕录制权限（而在先前的测试版更离谱，这个时间间隔更是只有一周，面对用户对频繁的弹窗授权表示不满，Apple 最终选择将时间间隔调整为 1 个月）。虽然安全，但是真烦。\n\n\nAmnesia 这个软件可以修改或者关闭这个新权限弹窗。",
    "timestamp": "2024-10-20T02:40:33.066Z"
  },
  {
    "id": "1729392022579",
    "content": "中式餐真的是不能吃啊，简直就是淀粉炸弹。中式早餐就是为了中国漫长的农业时代量身定制的，在现在的互联网时代，大早上吃一顿丰富的中式早餐，脑子一整个糊住了。",
    "timestamp": "2024-10-20T02:40:22.579Z"
  },
  {
    "id": "1729392014185",
    "content": "所有可以积累的事情都是有意义的。",
    "timestamp": "2024-10-20T02:40:14.185Z"
  },
  {
    "id": "1729392006304",
    "content": "Emotional enrollment is at the heart of performance, learning and connection.\n\n「情感投入」是「绩效、学习和连接」的核心。",
    "timestamp": "2024-10-20T02:40:06.304Z"
  },
  {
    "id": "1729391998357",
    "content": "经过 “你” 独特品味过滤、分享出去的内容，作为过滤者的 “你” 是重要的。你在关注什么内容、你有什么想法，就是意义。",
    "timestamp": "2024-10-20T02:39:58.357Z"
  },
  {
    "id": "1729391990193",
    "content": "Most knowledge worth having comes from practice. It comes from doing. It comes from creating. Reading about the trade war with China doesn’t make you smarter—it gives you something to say at dinner parties. It gives you the illusion that you have the vaguest idea what is happening in our enormously complex world.",
    "timestamp": "2024-10-20T02:39:50.193Z"
  },
  {
    "id": "1729391981601",
    "content": "大多数值得拥有的知识都来自于「实践」，来自于「做」，它来自于「创造」。阅读有关与中国的贸易战的文章并不会让你变得更聪明，而是让你在晚宴上有话可说。它给你一种错觉，你对我们极其复杂的世界中正在发生的事情有最模糊的了解。",
    "timestamp": "2024-10-20T02:39:41.601Z"
  },
  {
    "id": "1729391954935",
    "content": "永远记不住名字的 perplexity 在前些时候预发布了 macOS 客户端，目前可以预约，将在10月24日上架 Mac App Store。",
    "timestamp": "2024-10-20T02:39:14.935Z"
  },
  {
    "id": "1729295922461",
    "content": "麦当劳新品，14块：有蔬菜🥬，有淀粉🫓，有鸡蛋🍳，有咖啡☕️。\n\n\n真想给研发这种新品的人点个赞！非常了解打工族的需求。",
    "timestamp": "2024-10-18T23:58:42.461Z"
  },
  {
    "id": "1729127394652",
    "content": "Kindle 终于有彩色版啦！\n\n昨日（10 月 16 日）亚马逊公司旗下的电子书阅读器品牌 Kindle 发布了四款新产品，这四款新产品分别是：\n\n- 首款彩色屏幕的 **Kindle Colorsoft Signature Edition**。\n- 新版的 Kindle Paperwhite。\n- 抹茶绿色的新版 Kindle 阅读器。\n- 重新设计的 Kindle Scribe 阅读器。\n\n**Kindle Colorsoft Signature Edition** ：这是 Kindle 家族中的全新产品线，能够提供「如同在纸张上呈现出的丰富色彩」。配备 7 英寸的防眩光彩色屏幕，像素密度在黑白显示状态下为 300 ppi，在彩色显示状态下为 150 ppi。\n\n售价 $280 起，已开始接受预订，正式发货日期为 10 月 30 日。",
    "timestamp": "2024-10-17T01:09:54.652Z"
  },
  {
    "id": "1729127385348",
    "content": "娱乐应用 kill time，效率工具 save time，医疗延长时间。",
    "timestamp": "2024-10-17T01:09:45.348Z"
  },
  {
    "id": "1729127373214",
    "content": "不知道大家有没有发现一个现象，**所有经验性的人生智慧都可能是互相矛盾的**。\n\n- 有人说「好人有好报」，但还有人言之凿凿地说「好人没好报」；\n- 俗语说「瘦死的骆驼比马大」，但俗语还说「拔了毛的凤凰不如鸡」；\n- 有人告诉你，「宁可玉碎，不能瓦全」，但马上又有人说，「留得青山在，不怕没柴烧」；\n- 有人歌颂爱情，会说「在天愿作比翼鸟，在地愿为连理枝」，但也有人拒绝爱情，会说「夫妻本是同林鸟，大难来时各自飞」。\n\n所以，**在经验中，人们是永远无法得到确定性的人生智慧的**。\n\n——罗翔解读康德《道德形而上学原理》\n",
    "timestamp": "2024-10-17T01:09:33.214Z"
  },
  {
    "id": "1729127344267",
    "content": "沉浸式翻译团队的新产品  Bilin。\n\n\n不做总结，只是提供多语言的搜索结果，解决某个语言的互联网内容不够的问题。\n\n\n只提供内容的搜索类 AI会非常狭隘，这种就非常棒，能扩宽内容面。\n\n\nhttps://bilin.ai/zh-CN",
    "timestamp": "2024-10-17T01:09:04.267Z"
  },
  {
    "id": "1729126947710",
    "content": "**Figma 开发模式收费**\n\n长期以来，Figma 开发者模式（Dev Mode）一直是免费为用户提供的，它允许设计者（Design Mode）与开发者（Dev Mode）无缝合作，加快从概念到实现的过程。\n\n但是，Figma 宣布，从 2024 年 1 月 31 日起，Figma 开发者模式将不再免费，用户需要使用 Figma 开发者模式支付额外费用，具体为：团队用户每月 25 美元，企业用户每月 35 美元。",
    "timestamp": "2024-10-17T01:02:27.710Z"
  },
  {
    "id": "1728912991138",
    "content": "### 问题：\n图片的底部总是有一个缝隙，取消不掉。\n\n### 原因：\n是因为所有的 **行内块** 元素，包括 **img 图片** ，默认的垂直对齐方式，都是使用的 **vertical-align: baseline 基线对齐**。\n有的字母，比如 you 里面的 y，下面多一个。\n\n### 解决方法：\n修改图片的对齐方式，改为除 baseline 之外的任意一个都可以。\n常见的是 改为middle。\n\n### 应用：\n京东会把所有的img属性初始化：\n```CSS\nimg{border:0;vertical-align:middle}\n```",
    "timestamp": "2024-10-14T13:36:31.138Z"
  },
  {
    "id": "1728876380331",
    "content": "### 水平居中+垂直居中：\n```CSS\n\t/* 方法1： */\n\tleft: 50%;\n\ttop: 50%;\n\ttransform: translate(-50%, -50%);\n\t\n\t/* 方法2： */\n\tright: 50%;\n\tbottom: 50%;\n\ttransform: translate(50%, 50%);\n```\n\n",
    "timestamp": "2024-10-14T03:26:20.331Z"
  },
  {
    "id": "1728876372367",
    "content": "### 垂直居中：\n```CSS\n\t/* 方法1： */\n\ttop: 50%;\n\ttransform: translate(0, -50%);\n\t/* 方法2： */\n\tbottom: 50%;\n\ttransform: translate(0, 50%);\n```\n",
    "timestamp": "2024-10-14T03:26:12.367Z"
  },
  {
    "id": "1728876362790",
    "content": "### 水平居中：\n```CSS\n\t/* 方法1： */\n\tleft: 50%;\n\ttransform: translate(-50%, 0);\n\t/* 方法2： */\n\tright: 50%;\n\ttransform: translate(50%, 0);\n```\n",
    "timestamp": "2024-10-14T03:26:02.790Z"
  },
  {
    "id": "1728876348465",
    "content": "## 万能写法：\n`transform: translate(-50%, -50%);` \n让盒子位移：\n- 在x轴方向上，沿着反方向移动自身宽度的一半；\n- 在y轴方向上，沿着反方向移动自身高度的一半；",
    "timestamp": "2024-10-14T03:25:48.465Z"
  },
  {
    "id": "1728876336374",
    "content": "```CSS\n\t\t\t\t/* 上下居中 */\n\t\t\t\t\n\t\t\t\t/* 方法一： */\n\t\t\t\ttop: 50%;\n\t\t\t\tmargin-top: -100px;\n\t\t\t\t\n\t\t\t\t/* 方法二： ❌ 无效 */ \n\t\t\t\t/* 因为 margin 垂直50%是无效的 */ \n\t\t\t\tmargin-top: 50%;\n\t\t\t\ttop: -100px;\n\t\t\t\t\n\t\t\t\t/* 方法三： */\n\t\t\t\tbottom: 50%;\n\t\t\t\tmargin-bottom: -100px;\n\t\t\t\t\n\t\t\t\t/* 方法四： ❌ 无效 */\n\t\t\t\t/* 因为 margin 垂直50%是无效的 */ \n\t\t\t\tmargin-bottom: 50%;\n\t\t\t\tbottom: -100px;\n```",
    "timestamp": "2024-10-14T03:25:36.374Z"
  },
  {
    "id": "1728876311290",
    "content": "```CSS\n\t\t\t\t/* 绝对定位的盒子 */\n\t\t\t\tposition: absolute;\n\t\t\t\t\n\t\t\t\t/* 水平居中 */\n\t\t\t\t\n\t\t\t\t/* 方法一： */\n\t\t\t\tleft: 50%;\n\t\t\t\tmargin-left: -200px;\n\t\t\t\t\n\t\t\t\t/* 方法二： */\n\t\t\t\tmargin-left: 50%;\n\t\t\t\tleft: -200px;\n\t\t\t\t\n\t\t\t\t/* 方法三： */\n\t\t\t\tright: 50%;\n\t\t\t\tmargin-right: -200px;\n\t\t\t\t\n\t\t\t\t/* 方法四： */\n\t\t\t\tmargin-right: 50%;\n\t\t\t\tright: -200px;\n```",
    "timestamp": "2024-10-14T03:25:11.290Z"
  },
  {
    "id": "1728876273693",
    "content": "数学坐标系中的右手法则",
    "timestamp": "2024-10-14T03:24:33.693Z"
  },
  {
    "id": "1728876261180",
    "content": ".parent {\n    position: relative; /* 父元素相对定位 */\n}\n\n.child {\n    position: absolute; /* 子元素绝对定位 */\n    top: 0;            /* 子元素距离父元素顶部0像素 */\n    left: 0;           /* 子元素距离父元素左边0像素 */\n}",
    "timestamp": "2024-10-14T03:24:21.180Z"
  },
  {
    "id": "1728876251539",
    "content": "父盒子，必须占位置，是相对定位。\n子盒子，必须不能占位置，不占位置是绝对定位。",
    "timestamp": "2024-10-14T03:24:11.539Z"
  },
  {
    "id": "1728818859276",
    "content": "又下雨了哦🌧",
    "timestamp": "2024-10-13T11:27:39.276Z"
  },
  {
    "id": "1728646947634",
    "content": "在完成任务的同时，还需要不断“复盘”，不论多么忙，都需要留下时间思考，可以思考哪些地方做的好，哪些地方可以改进，应该如何改进，注重总结，让GPDCA不断循环的转起来，才能迭代进步。",
    "timestamp": "2024-10-11T11:42:27.634Z"
  },
  {
    "id": "1728646937072",
    "content": "今天把床🛏搬进了我的书房，只拿了床垫，看着真是舒服啊。特别是风一吹，窗帘随风飘动，太有感觉。而且今天不知道怎么了，一直睡不醒。结果就是，国庆节第一天，本来8点醒了，吃完早饭忙完，又睡到12点。",
    "timestamp": "2024-10-11T11:42:17.072Z"
  },
  {
    "id": "1728646929512",
    "content": "所有可以积累的事情都是有意义的。",
    "timestamp": "2024-10-11T11:42:09.512Z"
  },
  {
    "id": "1728646921166",
    "content": "Emotional enrollment is at the heart of performance, learning and connection.\n\n「情感投入」是「绩效、学习和连接」的核心。",
    "timestamp": "2024-10-11T11:42:01.166Z"
  },
  {
    "id": "1728646912684",
    "content": "经过 “你” 独特品味过滤、分享出去的内容，作为过滤者的 “你” 是重要的。你在关注什么内容、你有什么想法，就是意义。",
    "timestamp": "2024-10-11T11:41:52.684Z"
  },
  {
    "id": "1728646902857",
    "content": "大多数值得拥有的知识都来自于「实践」，来自于「做」，它来自于「创造」。阅读有关与中国的贸易战的文章并不会让你变得更聪明，而是让你在晚宴上有话可说。它给你一种错觉，你对我们极其复杂的世界中正在发生的事情有最模糊的了解。",
    "timestamp": "2024-10-11T11:41:42.857Z"
  },
  {
    "id": "1728646875354",
    "content": "大家都在走路的路，是安全的路。但不是登顶的路，不是珠穆朗玛峰的路。",
    "timestamp": "2024-10-11T11:41:15.354Z"
  },
  {
    "id": "1728548222692",
    "content": "Mac 总是莫名其妙 快捷键冲突、快捷键失效，今天终于找到病根了！原来在「服务」里，藏着大量自动添加的快捷键！大部分都是 ⌘+Shift+字母。\n\n\n位置：系统偏好设置 - 键盘 - 键盘快捷键 - 服务\n\n\n今天把这里一堆自动生成的快捷键全给清空了，非必要不给快捷键，除非是我手动自定义的。",
    "timestamp": "2024-10-10T08:17:02.693Z"
  },
  {
    "id": "1728548207902",
    "content": "每个人都有自己的时区。在这个急于求成的时代，焦虑似乎成了常态。我们总是被那些极少数成功个例所吸引，忘记了稳扎稳打，各有花期。\n\n\n想起了刘少楠发的那句话：「流水不争先，争的是滔滔不绝」。\n\n\n终身学习，无限进步。",
    "timestamp": "2024-10-10T08:16:47.902Z"
  },
  {
    "id": "1728548193445",
    "content": "即使是最穷的人，在他的小屋里也敢于对抗国王的权威。\n\n\n房子可能很破旧，房顶可能摇摇欲坠，风可以吹进这个房子，雨可以打进这个房子，但是国王不能踏进这个房子，他的千军万马也不敢跨过这间房子的门槛。\n\n\n——威廉·皮特 William Pitt",
    "timestamp": "2024-10-10T08:16:33.445Z"
  },
  {
    "id": "1728548171466",
    "content": "王小波说：人的一切痛苦，本质上都是对自己无能的愤怒。",
    "timestamp": "2024-10-10T08:16:11.466Z"
  },
  {
    "id": "1728111143500",
    "content": "中式餐真的是不能吃啊，简直就是淀粉炸弹。中式早餐就是为了中国漫长的农业时代量身定制的，在现在的互联网时代，大早上吃一顿丰富的中式早餐，脑子一整个糊住了。",
    "timestamp": "2024-10-05T06:52:23.500Z"
  },
  {
    "id": "1728111135830",
    "content": "所有可以积累的事情都是有意义的。",
    "timestamp": "2024-10-05T06:52:15.830Z"
  },
  {
    "id": "1728111128011",
    "content": "Emotional enrollment is at the heart of performance, learning and connection.\n「情感投入」是「绩效、学习和连接」的核心。",
    "timestamp": "2024-10-05T06:52:08.011Z"
  },
  {
    "id": "1728111113355",
    "content": "大多数值得拥有的知识都来自于「实践」，来自于「做」，它来自于「创造」。阅读有关与中国的贸易战的文章并不会让你变得更聪明，而是让你在晚宴上有话可说。它给你一种错觉，你对我们极其复杂的世界中正在发生的事情有最模糊的了解。\n\nMost knowledge worth having comes from practice. It comes from doing. It comes from creating. Reading about the trade war with China doesn’t make you smarter—it gives you something to say at dinner parties. It gives you the illusion that you have the vaguest idea what is happening in our enormously complex world.\n\nhttps://blog.tjcx.me/p/consume-less-create-more",
    "timestamp": "2024-10-05T06:51:53.355Z"
  },
  {
    "id": "1728111094716",
    "content": "Mac 总是莫名其妙 快捷键冲突、快捷键失效，今天终于找到病根了！原来在「服务」里，藏着大量自动添加的快捷键！大部分都是 ⌘+Shift+字母。\n\n位置：系统偏好设置 - 键盘 - 键盘快捷键 - 服务\n\n今天把这里一堆自动生成的快捷键全给清空了，非必要不给快捷键，除非是我手动自定义的。",
    "timestamp": "2024-10-05T06:51:34.716Z"
  },
  {
    "id": "1728111078783",
    "content": "每个人都有自己的时区。在这个急于求成的时代，焦虑似乎成了常态。我们总是被那些极少数成功个例所吸引，忘记了稳扎稳打，各有花期。\n\n想起了刘少楠发的那句话：「流水不争先，争的是滔滔不绝」。\n\n终身学习，无限进步。",
    "timestamp": "2024-10-05T06:51:18.783Z"
  },
  {
    "id": "1727755337777",
    "content": "今天不知道怎么了，一直睡不醒。结果就是，国庆节第一天，睡到12点。",
    "timestamp": "2024-10-01T04:02:17.777Z"
  },
  {
    "id": "1727755275111",
    "content": "- 相比之下，得到读书给我的感觉更像是一个「打着读书和知识幌子」的社交平台。\n    - 它的社交属性太强了，在产品的各个方面都体现得淋漓尽致。\n    - 比如最新推出的Get笔记功能，加入了邀请并延长录音时间的设计。这些功能虽然新颖，但对我来说并不是必需的。\n    - 得到的首页已经变成了一个推广的广告区域，让人应接不暇。虽然我可以通过小组件直接进入最近在学的内容，但这种设计仍然让我感到不适。\n    - 我并不是说要完全放弃得到，而是希望能在我真正想学习的时候才去使用它。\n",
    "timestamp": "2024-10-01T04:01:15.111Z"
  },
  {
    "id": "1727319730085",
    "content": "创造产品，最重要的是要考虑到社会需求。",
    "timestamp": "2024-09-26T03:02:10.085Z"
  },
  {
    "id": "1727319683533",
    "content": "# 切换到root用户\nsudo -i \n\n# 切换到root用户\nmkdir -p /root/data/docker_data/zfile\n\ncd /root/data/docker_data/zfile\n\nvim docker-compose.yml",
    "timestamp": "2024-09-26T03:01:23.533Z"
  },
  {
    "id": "1727229082572",
    "content": "今天看到和菜头说罗胖耳聋了，非常震惊，和董董董讨论，我们一致觉得是过大的压力导致的，毕竟罗胖真的挺拼的。\n\n今年罗胖的跨年演讲在杭州，我和董董董都很想去线下感受一下，毕竟线上追了那么多年。",
    "timestamp": "2024-09-25T01:51:22.572Z"
  },
  {
    "id": "1727227687990",
    "content": "今天开始想尝试一下达芬奇睡眠法了。除了健康，其他的没有什么好担心的。",
    "timestamp": "2024-09-25T01:28:07.990Z"
  },
  {
    "id": "1727194342942",
    "content": "啊啊啊啊",
    "timestamp": "2024-09-24T16:12:22.942Z"
  },
  {
    "id": "1727194315362",
    "content": "22222",
    "timestamp": "2024-09-24T16:11:55.362Z"
  },
  {
    "id": "1727187924937",
    "content": "11111",
    "timestamp": "2024-09-24T14:25:24.937Z"
  },
  {
    "id": "1727187717180",
    "content": "sikao",
    "timestamp": "2024-09-24T14:21:57.180Z"
  }
]